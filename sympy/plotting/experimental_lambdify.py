""" rewrite of lambdify - This stuff is not stable at all.

It is for internal use in the new plotting module.
It may (will! see the Q'n'A in the source) be rewritten.

It's completely self contained. Especially it does not use lambdarepr.

It does not aim to replace the current lambdify. Most importantly it will never
ever support anything else than sympy expressions (no Matrices, dictionaries
and so on).
"""

import re
from sympy import Symbol, NumberSymbol, I, zoo, oo

#  We parse the expression string into a tree that identifies functions. Then
# we translate the names of the functions and we translate also some strings
# that are not names of functions (all this according to translation
# dictionaries).
#  If the translation goes to another module (like numpy) the
# module is imported and 'func' is translated to 'module.func'.
#  If a function can not be translated, the inner nodes of that part of the
# tree are not translated. So if we have Integral(sqrt(x)), sqrt is not
# translated to np.sqrt and the Integral does not crash.
#  A namespace for all this is generated by crawling the (func, args) tree of
# the expression. The creation of this namespace involves many ugly
# workarounds.
#  The namespace consists of all the names needed for the sympy expression and
# all the name of modules used for translation. Those modules are imported only
# as a name (import numpy as np) in order to keep the namespace small and
# manageable.

#  Please, if there is a bug, do not try to fix it here! Rewrite this by using
# the method proposed in the last Q'n'A below. That way the new function will
# work just as well, be just as simple, but it wont need any new workarounds.
#  If you insist on fixing it here, look at the workarounds in the function
# sympy_expression_namespace and in lambdify.

# Q: Why are you not using python abstract syntax tree?
# A: Because it is more complicated and not much more powerful in this case.

# Q: What if I have Symbol('sin') or g=Function('f')?
# A: You will break the algorithm. We should use srepr to defend against this?
#  The problem with Symbol('sin') is that it will be printed as 'sin'. The
# parser will distinguish it from the function 'sin' because functions are
# detected thanks to the opening parenthesis, but the lambda expression won't
# understand the difference if we have also the sin function.
# The solution (complicated) is to use srepr and maybe ast.
#  The problem with the g=Function('f') is that it will be printed as 'f' but in
# the global namespace we have only 'g'. But as the same printer is used in the
# constructor of the namespace there will be no problem.

# Q: What if some of the printers are not printing as expected?
# A: The algorithm wont work. You must use srepr for those cases. But even
# srepr may not print well. All problems with printers should be considered
# bugs.

# Q: What about _imp_ functions?
# A: Those are taken care for by evalf. A special case treatment will work
# faster but it's not worth the code complexity.

# Q: Will ast fix all possible problems?
# A: No. You will always have to use some printer. Even srepr may not work in
# some cases. But if the printer does not work, that should be considered a
# bug.

# Q: Is there same way to fix all possible problems?
# A: Probably by constructing our strings ourself by traversing the (func,
# args) tree and creating the namespace at the same time. That actually sounds
# good.

def experimental_lambdify(args, expr, print_lambda=False):
    # Constructing the argument string
    if not all([isinstance(a, Symbol) for a in args]):
        raise ValueError('The arguments must be Symbols.')
    else:
        argstr = ', '.join([str(a) for a in args])

    # Constructing the translation dictionaries and making the translation
    dict_tuple_str = get_dict_tuple_str()
    dict_tuple_fun = get_dict_tuple_fun()
    exprstr = str(expr)
    newexpr = tree2str_translate(str2tree(exprstr), dict_tuple_str, dict_tuple_fun)

    # Constructing the namespaces
    namespace = {}
    namespace.update(sympy_atoms_namespace(expr))
    namespace.update(sympy_expression_namespace(expr))
    # XXX Workaround
    # Ugly workaround because Pow(a,Half) prints as sqrt(a)
    # and sympy_expression_namespace can not catch it.
    from sympy import sqrt
    namespace.update({'sqrt': sqrt})
    # End workaround.
    try:
        namespace.update({'np' : __import__('numpy')})
    except ImportError:
        raise ImportError('experimental_lambdify needs numpy.')

    if print_lambda:
        print newexpr
    return eval('lambda ' + argstr + ' : (' + newexpr + ')', namespace)


##############################################################################
# Dicts for translating from sympy to other modules
##############################################################################

###
# numpy
###

# Functions that are the same in numpy
numpy_functions_same = [
        'sin', 'cos', 'tan',
        'sinh', 'cosh', 'tanh',
        'sqrt',
        'floor',
        'conjugate',
        ]

# Functions with different names in numpy
numpy_functions_different = {
        "acos":"arccos",
        "acosh":"arccosh",
        "arg":"angle",
        "asin":"arcsin",
        "asinh":"arcsinh",
        "atan":"arctan",
        "atan2":"arctan2",
        "atanh":"arctanh",
        "ceiling":"ceil",
        "im":"imag",
        "ln":"log",
        "Max":"amax",
        "Min":"amin",
        "re":"real",
        }

# Strings that should be translated
numpy_not_functions = {
        'I' : '1j',
        'oo':'inf',
        'E':'e',
        }

###
# mpmath, python math, etc
###
# Not needed really

###
# Create the final ordered tuples of dictionaries
###

# For strings
def get_dict_tuple_str():
    return (numpy_not_functions,)

# For functions
def get_dict_tuple_fun():
    numpy_dict = {}
    for s in numpy_functions_same:
        numpy_dict[s] = 'np.'+s
    for k in numpy_functions_different:
        numpy_dict[k] = 'np.'+numpy_functions_different[k]
    return (numpy_dict, )

##############################################################################
# The translator functions, tree parsers, etc.
##############################################################################

def str2tree(exprstr):
    """Converts an expression string to a tree.

    Functions are represented by ('func_name(', tree_of_arguments).
    Other expressions are (head_string, mid_tree, tail_str).
    Expressions that do not contain functions are directly returned.

    Examples:
    >>> from sympy.abc import x, y, z
    >>> from sympy import Integral, sin
    >>> from sympy.plotting.experimental_lambdify import str2tree

    >>> str2tree(str(Integral(x, (x, 1, y))))
    ('', ('Integral(', 'x, (x, 1, y)'), ')')
    >>> str2tree(str(x+y))
    'x + y'
    >>> str2tree(str(x+y*sin(z)+1))
    ('x + y*', ('sin(', 'z'), ') + 1')
    """
<<<<<<< HEAD
    #matches the first 'function_name('
    first_par = re.match(r'[^\(]*?[\W]?(\w+\()', exprstr)
    if first_par is None:
        return exprstr
    else:
        start = len(first_par.group()) - len(first_par.groups()[0])
        head = exprstr[:start]
        func = exprstr[start:first_par.end()]
        tail = exprstr[first_par.end():]
        count = 0
        for i, c in enumerate(tail):
            if c == '(':
                count += 1
            elif c == ')':
                count -= 1
            if count == -1:
                break
        func_tail = str2tree(tail[:i])
        tail = str2tree(tail[i:])
        return (head, (func, func_tail), tail)

def tree2str(tree):
    """Converts a tree to string without translations.

    Examples:
    >>> from sympy.abc import x, y, z
    >>> from sympy import Integral, sin
    >>> from sympy.plotting.experimental_lambdify import str2tree, tree2str

    >>> tree2str(str2tree(str(x+y*sin(z)+1)))
    'x + y*sin(z) + 1'
    """
    if isinstance(tree, str):
        return tree
    else:
        return ''.join(map(tree2str, tree))

def tree2str_translate(tree, dict_tuple_str, dict_tuple_fun):
    """Converts a tree to string with translations.

    Function names are translated by translate_func.
    Other strings are translated by translate_str.
    """
    if isinstance(tree, str):
        return translate_str(tree, dict_tuple_str)
    elif isinstance(tree, tuple) and len(tree) == 2:
        return translate_func(tree[0][:-1], tree[1], dict_tuple_str, dict_tuple_fun)
    else:
        return ''.join([tree2str_translate(t, dict_tuple_str, dict_tuple_fun) for t in tree])

def translate_str(estr, dict_tuple_str):
    """Translate substrings of estr using in order the dictionaries in
    dict_tuple_str."""
    for trans_dict in dict_tuple_str:
        for k in trans_dict.keys():
            while estr.find(k) is not -1:
                i = estr.find(k)
                estr = estr[:i] + trans_dict[k] + estr[i+len(k):]
    return estr

def translate_func(func_name, argtree, dict_tuple_str, dict_tuple_fun):
    """Translate function names and the tree of arguments.

    If the function name is not in the dictionaries of dict_tuple_fun then the
    function is surrounded by an (...).evalf()."""
    for trans_dict in dict_tuple_fun:
        if func_name in trans_dict:
            new_name = trans_dict[func_name]
            argstr = tree2str_translate(argtree, dict_tuple_str, dict_tuple_fun)
            break
    else:
        new_name = '(' + func_name
        argstr = tree2str(argtree) + ').evalf()'
    return new_name + '(' + argstr

##############################################################################
# The namespace constructors
##############################################################################

def sympy_expression_namespace(expr):
    """Traverses the (func, args) tree of an expression and creates a sympy
    namespace. All other modules are imported only as a module name. That way
    the namespace is not poluted and rests quite small."""
    if expr is None:
        return {}
    else:
        funcname = str(expr.func)
=======
    def __init__(self, args, expr, tol = 1e-15):
        self.args = args
        self.expr = expr
        self.lambda_func = experimental_lambdify(args, expr, use_np=True)
        self.vector_func = self.lambda_func
        self.failure = False
        self.tol = tol

    def __call__(self, *args):
        # TODO: This can be simplified. Check the last failback.
        np_old_err = np.seterr(invalid='raise')
        try:
            results = self.vector_func(*args)
            #results can have complex values without causing an exception.
            if results.dtype == 'complex':
                results = np.array([ a.real if np.abs(a.imag) < self.tol else None for a in results])
        except Exception, e:
            np.seterr(**np_old_err)
            #DEBUG: print 'Error', type(e), e
            if (isinstance(e, FloatingPointError)
                and 'invalid value encountered in' in str(e)):
                # All functions were translated to numpy but
                # complex number were produced and returned as nan.
                # Solution: demand the use of np.complex128.
                # Discard values which have imag part > tol
                args = (np.array(a, dtype=np.complex) for a in args)
                results = self.vector_func(*args)
                results = np.array([ a.real if np.abs(a.imag) < self.tol else None for a in results])
                warnings.warn('Complex values encountered. Discarding Complex values for plot')
            elif ((isinstance(e, TypeError )
                   and 'unhashable type: \'numpy.ndarray\'' in str(e))
                  or
                  (isinstance(e, ValueError)
                   and ('Invalid limits given:' in str(e)
                        or 'negative dimensions are not allowed' in str(e) #XXX
                        or 'sequence too large; must be smaller than 32' in str(e)))): #XXX
                # Almost all functions were translated to numpy, but some were
                # left as sympy functions. They recieved an ndarray as an
                # argument and failed.
                #   sin(ndarray(...)) raises "unhashable type"
                #   Integral(x, (x, 0, ndarray(...))) raises "Invalid limits"
                #   other ugly exceptions that are not well understood (marked with XXX)
                # Solution: use math and vectorize the final lambda.
                self.lambda_func = experimental_lambdify(self.args, self.expr, use_python_math=True)
                self.vector_func = np.vectorize(self.lambda_func, otypes=[np.float])
                results = self.__call__(*args)
            elif (isinstance(e, ValueError)
                  and
                  ('Symbolic value, can\'t compute' in str(e) or 'math domain error' in str(e))):
                # Almost all functions were translated to python math, but some
                # were left as sympy functions. They produced complex numbers.
                #   float(a+I*b) raises "Symbolic value, can't compute"
                #   math.sqrt(-1) raises "math domain error"
                # Solution: use cmath and vectorize the final lambda.
                self.lambda_func = experimental_lambdify(self.args, self.expr, use_python_cmath=True)
                self.vector_func = np.vectorize(self.lambda_func, otypes=[np.complex])
                results = self.__call__(*args)
                results = np.array([ a.real if np.abs(a.imag) < self.tol else None for a in results])
                warnings.warn('Complex values encountered. Discarding complex values for plot')
            else:
                # Complete failure. One last try with no translations, only
                # wrapping in complex((...).evalf()) and returning the real
                # part.
                if self.failure:
                    raise e
                else:
                    self.failure = True
                    self.lambda_func = experimental_lambdify(self.args, self.expr,
                                                        use_evalf=True,
                                                        complex_wrap_evalf=True)
                    self.vector_func = np.vectorize(self.lambda_func, otypes=[np.complex])
                    results = np.real(self.__call__(*args))
                    warnings.warn('The evaluation of the expression is'
                            ' problematic. We are trying a failback method'
                            ' that may still work. Please report this as a bug.')
        return results


def experimental_lambdify(*args, **kwargs):
    l = Lambdifier(*args, **kwargs)
    return l.lambda_func


class Lambdifier(object):
    def __init__(self, args, expr, print_lambda=False,
                                   use_evalf=False,
                                   float_wrap_evalf=False,
                                   complex_wrap_evalf=False,
                                   use_np=False,
                                   use_python_math=False,
                                   use_python_cmath=False):

        self.print_lambda = print_lambda
        self.use_evalf = use_evalf
        self.float_wrap_evalf = float_wrap_evalf
        self.complex_wrap_evalf = complex_wrap_evalf
        self.use_np = use_np
        self.use_python_math = use_python_math
        self.use_python_cmath = use_python_cmath

        # Constructing the argument string
        if not all([isinstance(a, Symbol) for a in args]):
            raise ValueError('The arguments must be Symbols.')
        else:
            argstr = ', '.join([str(a) for a in args])

        # Constructing the translation dictionaries and making the translation
        self.dict_str = self.get_dict_str()
        self.dict_fun = self.get_dict_fun()
        exprstr = str(expr)
        newexpr = self.tree2str_translate(self.str2tree(exprstr))

        # Constructing the namespaces
        namespace = {}
        namespace.update(self.sympy_atoms_namespace(expr))
        namespace.update(self.sympy_expression_namespace(expr))
>>>>>>> complex values are discarded in plot
        # XXX Workaround
        # Here we add an ugly workaround because str(func(x))
        # is not always the same as str(func). Eg
        # >>> str(Integral(x))
        # "Integral(x)"
        # >>> str(Integral)
        # "<class 'sympy.integrals.integrals.Integral'>"
        # >>> str(sqrt(x))
        # "sqrt(x)"
        # >>> str(sqrt)
        # "<function sqrt at 0x3d92de8>"
        # >>> str(sin(x))
        # "sin(x)"
        # >>> str(sin)
        # "sin"
        # Either one of those can be used but not all at the same time.
        # The code considers the sin example as the right one.
        regexlist = [
                r'<class \'sympy[\w.]*?.([\w]*)\'>$', # the example Integral
                r'<function ([\w]*) at 0x[\w]*>$',    # the example sqrt
                ]
        for r in regexlist:
            m = re.match(r, funcname)
            if m is not None:
                funcname = m.groups()[0]
        # End of the workaround
        # XXX debug: print funcname
        args_dict = {}
        for a in expr.args:
            if (isinstance(a, Symbol) or
                isinstance(a, NumberSymbol) or
                a in [I, zoo, oo]):
                continue
            else:
                args_dict.update(sympy_expression_namespace(a))
        args_dict.update({funcname : expr.func})
        return args_dict

def sympy_atoms_namespace(expr):
    """For no real reason this function is separated from
    sympy_expression_namespace. It can be moved to it."""
    atoms = expr.atoms(Symbol, NumberSymbol, I, zoo, oo)
    d = {}
    for a in atoms:
        # XXX debug: print 'atom:' + str(a)
        d[str(a)] = a
    return d
